#### 性能优化

1. 更改config/index.js中的productionSourceMap为false，可以减少打包的体积
2. 自定义插件引入用到的ui组件
3. 路由懒加载

#### mixin
> 公共的事务用mixin(几个组件要同时发送一个请求数据字典，在每个组件里面都要发送请求，在mixin里面就发送一次请求)，可在里面写生命钩子，及所有的参数，当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项，this.$options.name可以拿到组件名

    export default{
        created(){
            console.log("我是混合器");
        }
    }

* 局部声明
> 引入mixin的组件都会执行mixin里面的内容

    import myMixins from "./store/mixins";
    export default {
        mixins: [myMixins]
    };

* 全局声明
> 所有组件都会执行mixin中的内容

    Vue.mixin({
        created(){
            console.log("我是混合器");
        }
    });

* 选项合并
    * 数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先
    * 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用
    * 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对

#### 骨架屏原理
> 主要解决首屏卡顿的问题，优化用户体验（将骨架放入id=app里面，然后隐藏，在根据路由来显示相应的骨架）

#### 多页应用
> 几个项目在webpack中一次打包，主要修改`html-webpack-plugin`插件

* filename: 文件名
* template: 模板，就是以那个HTML文件为模板，可以用path来获取路径

1 添加base.conf.js里面的entry，该路径为项目根路径
2 在HtmlWebpackPlugin添加 `chunks: ["manifest", "vendor", "user"]`, 其中的user为entry的key，必须加这段，不然打包会将所有的文件都加在一个文件里面

###### 打开默认页面
> 如果不是index.html，则不会打开默认页面

* 开发环境: 在package.json文件中添加`--open-page user.index.html`

* 生产环境: 设置server节点

#### 前后端分离解决跨域

* 开发环境

        在dev.conf.js文件中找到devServer，配置以下，其中必须有changeOrigin字段，或者找到config/index.js找到proxyTable字段，配置如下，不成功则要安装`npm install https-proxy-agent --save-dev`
        proxy: {
            '/api': {
                target: 'http://apis.juhe.cn/geo',
                pathRewrite: {'^/api' : ''},
                changeOrigin: true
            }
        }

* 生产环境：配置服务器

#### 预渲染
> 单页应用中首先加载index.html，index.html入口内容都在build.js里面，不利于SEO，在单页中预先渲染部分静态数据，不变化的页面

#### PWA（渐进式/web/application）
> 持续关注PWA，积极研究其中应用场景，谷歌公司将现有的技术，结合起来推广的一整套的方案

> 只能用在localhost和https协议上面

* 应用
    * 离线浏览web应用
    * 生产桌面应用
    * 顶部通知
    * 预缓存
    * 分享

#### service worker
> 本质就是浏览器开启的一个线程（类似webworker），该线程可以拦截请求，发请求(类似node服务器)

###### service worker扮演着代理的角色，将客户端的请求拦截，自己发送请求，并且结合cache存储数据，从而实现离线浏览

#### nuxt.js(SSR Server Site Render)
> 服务端渲染，根据请求的URL，动态的将模板与数据结合并响应给客户端，简而言之，nuxt.js是帮助vue.js轻松完成服务端渲染的框架,解决SEO的问题

* 刷新，地址栏回车 => URL改变，服务器渲染，点击nuxt-link相当于点击a标签，禁止a标签的跳转，并根据其href属性,通过history.pushState改变地址栏发起请求或者具体的客户端渲染行为,局部替换内容
* nuxt前端路由沿用了history模式,通过history.pushState更改url,进而局部渲染组件
* 而首屏刷新的时候,通过后端计算并模板渲染，将html响应给客户端,一定程度解决了首屏白屏的问题

###### 文件夹结构

* assets：需要编译的资源文件,less,js,css,会在dist下根据hash数字签名生成文件，当原文件被改动，url也被改动，避免缓存
* static：不需要编译或者缓存问题资源文件
* components：公共组件
* layouts：头体底 组件
* muddleware：中间件,应用过程中发生的事
* pages：路由页面
* plugins：插件
* store：vuex

*一辈子很短，努力的做好两件事就好；第一件事是热爱生活，好好的去爱身边的人；第二件事是努力学习，在工作中取得不一样的成绩，实现自己的价值。*