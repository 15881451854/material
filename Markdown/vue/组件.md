## 组件
> 组件（Component）是前端在单页面应用（SPA）上最好的一种实现方式，把所有功能模块拆解成单独的组件，每个组件都有独立的作用域，且还可以相互通信

#### 认识单页面应用（SPA）
> 在传统的页面之间跳转，是通过刷新，重新渲染一个页面而实现，在渲染的过程中势必要加载外部资源文件，页面在服务器中渲染出来是通过一系列的生命周期，在这个过程中会因为网速等硬件问题直接影响页面的加载速度，为解决这一问题，前端在新的设计模式上引入了组件的概念，页面之间的跳转变成了组件之间的切换，不需要重新加载整个页面，也不用考虑页面的生命周期，换成组件的生命周期，在性能上大大的提升了

#### 组件名大小写
> 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 \<my-component-name> 和 \<MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的

1. kebab-case：`Vue.component('my-component-name', { /* ... */ })`
2. PascalCase：`Vue.component('MyComponentName', { /* ... */ })`

#### 全局组件
> template里面只能有一个根元素，不能有兄弟元素

        <div id="app">
            <global-component></global-component>
        </div>
        Vue.component('global-component', {
            template: '<h1>全局组件</h1>'
        })

#### 局部组件
> 在组件里面 data 一定是 function 并返回一个对象

        <div id="app">
            <private-component></private-component>
        </div>
        var vm = new Vue({
            el: '#app',
            components:{
                'private-component': {
                    template: '<h1>局部组件</h1>'
                }
            }
        })

#### 组件是一个单独的作用域
> 每个组件都会各自独立维护它。因为你每用一次组件，就会有一个它的新实例被创建

        var vm = new Vue({
            components:{
                'component1': {
                    template: '<button>{{ count }}</button>',
                    data: function(){
                        //在组件里面 data 一定是 function 并返回一个对象
                        return {
                            count: 0
                        }
                    }
                }
            }
        })

#### 组件属性props
> 组件的属性要先声明后使用，props: ['属性名'...]

        <div id="app">
            <private-component title="组件属性" :text="mess"></private-component>
        </div>
        var vm = new Vue({
            el: '#app',
            data: {
                mess: '-动态属性'
            }
            components:{
                'private-component': {
                    template: '<h1>{{title + text}}</h1>',
                    props: ['title', 'text']
                }
            }
        }
###### 单向数据流
> 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告

###### Prop验证
> 我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助

        Vue.component('my-component', {
        props: {
            // 基础的类型检查 (`null` 匹配任何类型)
            propA: Number,
            // 多个可能的类型
            propB: [String, Number],
            // 必填的字符串
            propC: {
            type: String,
            required: true
            },
            // 带有默认值的数字
            propD: {
            type: Number,
            default: 100
            },
            // 带有默认值的对象
            propE: {
            type: Object,
            // 对象或数组默认值必须从一个工厂函数获取
            default: function () {
                return { message: 'hello' }
            }
            },
            // 自定义验证函数
            propF: {
            validator: function (value) {
                // 这个值必须匹配下列字符串中的一个
                return ['success', 'warning', 'danger'].indexOf(value) !== -1
            }
            }
        }
        })
###### 类型检查
> type 可以是下列原生构造函数中的一个

* String
* Number
* Boolean
* Array
* Object
* Date
* Function
* Symbol

#### 特殊的 HTML 结构中使用 is
> 特殊的 HTML 结构中使用 is

        <div id="app">
            <select>
                <option is="privateOption"></option>
            </select>
        </div>

#### 动态组件 - :is
> 有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里。`<p :is="show"></p>`: 定义一个data: show，再在组件里面定义与data可能值相同的组件

#### 组件自定义事件
> <组件名 v-on:自定义事件名="">，必须用v-on定义，自定义事件名不需要声明，直接用 $emit() 触发

    <div id="app">
        <increment v-on:count="increment"></increment>
    </div>
    var vm = new Vue({
         methods: {
            increment: function(){
            }
        },
        components: {
            'increment': {
                template: '<input type="button" @click="incrementTotal"/>',
                methods: {
                    incrementTotal: function(){
                        this.$emit('count')
                    }
                }
            }
        }
    })
> 在v-on里面可以添加一个\$event定义形参，\$emit的第二个参数是实参`this.$emit('count', 666)`, 由于单向数据流, 子组件不能改变父组件的值，自定义方法可以子组件改变父组件的值

#### \$emit, \$on（EventBus）
> 用于组件之间的传递参数，\$emit,\$on的事件必须在一个公共的实例上才能触发，可以理解为\$on是自定义的一个方法，\$emit是去触发这个方法，必须绑定到一个公共的实例上

        var Event = new Vue();
        var vm = new Vue({
            el: '#app',
            data: function(){
                return {

                }
            },
            components: {
                "Aconponent": {
                    template: `<div @click="change">{{msg}}</div>`,
                    data: ()=>{
                        return {
                            msg: "我是组件a的数据"
                        }
                    },
                    methods: {
                        change: function(){
                            Event.$emit("a", this.msg);
                        }
                    }
                },
                "Bcomponent": {
                    template: `<div @click="change">{{msg}}</div>`,
                    data: ()=>{
                        return {
                            msg: "我是组件b的数据"
                        }
                    },
                    methods: {
                        change: function(){
                            Event.$emit("b", this.msg);
                        }
                    }
                },
                "Ccomponent": {
                    template: `<div><p>{{a}}</p><p>{{b}}</p></div>`,
                    data: function(){
                        return {
                            a: "a",
                            b: ""
                        }
                    },
                    mounted: function(){
                        Event.$on("a", (a)=>{
                            this.a = a;
                        });
                        Event.$on("b", (a)=>{
                            this.a = a;
                        })
                    }
                }
            }
        })

#### slot 分发内容
> Vue 组件默认是覆盖渲染，为了解决这一问题，Vue 提出了 slot 分发内容

        <div id="app">
            <component1>
                <h1>Sam</h1>
                <h1>Lucy</h1>
            </component1>
        </div>
        Vue.component('component1', {
            template: `
                <div>
                    <h1>Tom</h1>
                    <slot></slot>
                </div>
            `
        })
> conponent1中的内容默认放到slot里面

###### 具名 slot
> 如果要将组件里面不同的子元素放到不同的地方，那就为子元素加上一个属性 slot="名称"，然后在组件定义的时候用name对应位置 ，其它没有 slot 属性的子元素将统一分发到 slot 里面

        <div id="app">
            <component1>
                <h1>Sam</h1>
                <h1 slot="lucy">Lucy</h1>
            </component1>
        </div>
        Vue.component('component1', {
            template: `
                <div>
                    <slot name="lucy"></slot>
                    <h1>Tom</h1>
                    <slot></slot>
                </div>
            `
        })

###### 插槽的默认内容
> 有的时候为插槽提供默认的内容是很有用的。例如，一个 <submit-button> 组件可能希望这个按钮的默认内容是“Submit”，但是同时允许用户覆写为“Save”、“Upload”或别的内容

        <button type="submit">
            <slot>Submit</slot>
        </button>

#### 过滤器

###### 局部过滤器
> 内部一定要return, value默认传递, arg是形参

    var vm = new Vue({
        el: '#app',
        filters: {
            text: function(value, arg){
                return value+"$";
            }
        }
    })

使用
> 数据属性 | 过滤器名字

    <h1>{{msg | text}}</h1>

###### 全局过滤器

    Vue.filter("myReverse", function(value){

    })

#### 模版写法

        <template id="component1">
            <div>
                <input type="text" v-model="name"/>
                <p>{{name}}</p>			
            </div>
        </template>

        <div id="app">
            <component1/>
        </div>  

        var vm = new Vue({
            el: '#app',
            components: {
                'component1': {
                    template: '#component1',
                    data: function(){
                        return {name: 'Tom'};
                    }
                }
            }
        })


*一辈子很短，努力的做好两件事就好；第一件事是热爱生活，好好的去爱身边的人；第二件事是努力学习，在工作中取得不一样的成绩，实现自己的价值。*