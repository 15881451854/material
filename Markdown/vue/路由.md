## Vue 路由
> 通过 URL 映射到对应的功能实现

1. 引入 vue.js
2. 引入 vue-router.js
3. 让vue使用vueRouter, `vue.use(vueRouter)`
4. 创建路由对象，配置路由对象
5. 将配置好的路由对象关联到vue的实例化对象中

        <div id="app">
            <router-link to="/foo">foo</router-link>
            <router-link to="/bar">bar</router-link>
            <router-view></router-view>
        </div>

        <script>
            var foo = {template: "<h1>foo</h1>"};
            var bar = {template: "<h1>bar</h1>"};
            var routes = [
                {path: "/foo", component: foo},
                {path: "/bar", component: bar},
            ];

            var router = new VueRouter({
                routes: routes
            })

            var vm = new Vue({
                el: '#app',
                router: router
            })
        </script>

* router-link: 组件导航, to 属性指定链接, 解析为a标签
* router-view: 路由匹配的组件在此处渲染

#### 路由参数

* 在path后面加`/:xx`
* 通过对象 **$route.params.xx** 来获取参数

        <div id="app">
            <router-link to="/foo/params">foo</router-link>
            <router-link to="/bar">bar</router-link>
            <router-view></router-view>
        </div>

        <script>
            var foo = {template: "<h1>foo{{$route.params.userid}}</h1>"};
            var bar = {template: "<h1>bar</h1>"};
            var routes = [
                {path: "/foo/:userid", component: foo},
                {path: "/bar", component: bar},
            ];

            var router = new VueRouter({
                routes: routes
            })

            var vm = new Vue({
                el: '#app',
                router: router
            })
        </script>

###### Router-link跳转路径的书写的几种方式

* 直接书写路径`<router-link to="/about"></router-link>`
* 动态指定`<router-link :to="{path:'about'}"></router-link>`
* 通过name动态绑定，防止路径过长`<router-link :to="{name:'about',params:{userId:123}}"></router-link>`

#### 嵌套路由
> 嵌套路由路径不用写 "/"

    <div id="app">
        <router-link to="/foo">foo</router-link>
        <router-link to="/bar">bar</router-link>
        <router-view></router-view>
    </div>

    <script>
        var foo = {
            template: `<div>
                            <h1>foo</h1>
                            <router-link to="/foo/bar1">bar1</router-link>
                            <router-view></router-view>
                        </div>`
        };
        var bar = { template: "<h1>bar</h1>" };
        var routes = [
            {
                path: "/foo",
                component: foo,
                children: [{
                    path: "bar1",     // 子路由路径不用写"/"
                    component: bar
                }]
            },
            { path: "/bar", component: bar },
        ];

        var router = new VueRouter({
            routes: routes
        })

        var vm = new Vue({
            el: '#app',
            router: router
        })
    </script>

#### 编程式导航
> 用 javascript 跳转路由

* 用 `router-link` 组件进行跳转
`<router-link to="/floor1">一楼</router-link>`

* 编程式导航1：\$router.replace()
`<input type="button" value="一楼" @click="$router.replace('/floor1')">`

* 编程式导航2：\$router.push()
`<input type="button" value="一楼" @click="$router.push('/floor1')">`

* 编程式导航3：\$router.push({})
`<input type="button" value="一楼" @click="$router.push({path: '/floor1'})">`

* 编程式导航4：\$router.push({}) 传参数 #/floor1/123
`<input type="button" value="一楼" @click="$router.push({name: 'floor1', params: {id: 123}})">`
> 注意：如果提供了 path，params 会被忽略

* 编程式导航5：\$router.push({}) 传参数 #/floor1?id=123
`<input type="button" value="一楼" @click="$router.push({path: '/floor1', query: {id: 123}})">`

* 编程式导航6：\$router.go() 接收一个整数，意思是在 history 记录中向前或者后退多少步
 
###### 获取路由参数

1. params：在目标页面通过this.$route.params.xxx获取参数
2. query：在目标页面通过this.$route.query.xxx

#### 命名路由
> 在路由映射表中添加属性 name，用以对该路由映射规则命名，在编程式导航跳转路由时可以用 router.push({name: '名称'}), 建议每次都写上name

        var routes = [
            {
                path: "/foo/:id",
                name:"foo",
                component: foo,
                children: [{
                    path: "bar1",
                    component: bar
                }]
            },
            { path: "/bar", component: bar },
        ];

#### 命名视图

    <div id="app">
        <h1>Hello VueRouter</h1>
        <p>
            <router-view></router-view>
            <router-view name="a"></router-view>
            <router-view name="b"></router-view>
        </p>
    </div>
    const router = new VueRouter({
        routes: [
            {
                path: '/',
                components: {
                    default: {
                        template: '<h1>defalut router view</h1>'
                    },
                    a: {
                        template: '<h1>a router view</h1>'
                    },
                    b: {
                        template: '<h1>b router view</h1>'
                    }
                }
            }
        ]
    })
    new Vue({
        el: '#app',
        router
    })

> default 默认在router-view渲染, 同slot

#### 路由重定向
> 默认渲染的路由

        var router = new VueRouter({
            routes:[
                {path: "/", redirect: "/home"}
            ]
        });

###### 配置404
> 当输入不存在的路由的时候，可以用 * 来匹配一个404页面：`{path: "*", name: "notFound", component: notFoundComponent}`

#### 导航守卫

1. 全局守卫
> router.beforeEach 注册一个全局前置守卫

        var router = new VueRouter({
            routes:[
                {path: "/login", name: "login", component: loginConponent, meta: {isLogin: true}},   // 路由源信息
            ]
        });
        router.beforeEach((to, from, next) => {   // 路由守卫
            next()
        })

* to: Route: 即将要进入的目标 路由对象
* from: Route: 当前导航正要离开的路由
* next: Function: **确保要调用 next 方法，否则钩子就不会被 resolved**
    * next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
    * next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
    * next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。
    * next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调

2. 组件内的守卫
> 可以在路由组件内直接定义以下路由导航守卫

* beforeRouteEnter
* beforeRouteUpdate
* beforeRouteLeave

        const Foo = {
            template: `...`,
            beforeRouteEnter (to, from, next) {
                // 在渲染该组件的对应路由被 confirm 前调用
                // 不！能！获取组件实例 `this`
                // 因为当守卫执行前，组件实例还没被创建
            },
            beforeRouteUpdate (to, from, next) {
                // 在当前路由改变，但是该组件被复用时调用
                // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
                // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
                // 可以访问组件实例 `this`
            },
            beforeRouteLeave (to, from, next) {
                // 导航离开该组件的对应路由时调用
                // 可以访问组件实例 `this`
            }
        }

#### 路由源信息
> 在配置参数里面添加meta对象

#### keep-alive
> 内置组件，缓存组件

#### 路由懒加载
> 当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了

* 引入组件：`const Foo = () => import('./Foo.vue');`
* 在路由配置中什么都不需要改变，只需要像往常一样使用

###### 把组件按组分块
> 有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)

    const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')
    const Bar = () => import(/* webpackChunkName: "group-foo" */ './Bar.vue')
    const Baz = () => import(/* webpackChunkName: "group-foo" */ './Baz.vue')

###### 如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法，可能会有版本问题

* npm install babel-plugin-syntax-dynamic-import
* 再在.babelrc中加入

        {
            "plugins": ["syntax-dynamic-import"]
        }

*一辈子很短，努力的做好两件事就好；第一件事是热爱生活，好好的去爱身边的人；第二件事是努力学习，在工作中取得不一样的成绩，实现自己的价值。*