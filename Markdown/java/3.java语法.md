## java 基本语法

#### java的编程规范

* 在程序中自定义的一些名称，标识符
    * 由26个英文字母(大小写)，数字，符号（_ $）组成
    * 不能以数字开头，不能使用关键字
    * 要尽量有意义，见名知意原则
* 类的命名规则
    * 如果是一个单词 首字母大写
    * 如果是多个单词 每个单词首字母大写(驼峰命名)
* 方法的命名规则:
    * 如果是一个单词 全部小写
    * 如果是多个单词 从第二个单词首字母大写

#### 常量
> 常量表示不能改变的数值

* 常量的分类
    * 字面值常量
    * 自定义常量
* 字面值常量的分类
    * 字符串常量：用双引号括起来的内容（java单引号与双引号有区别）
    * 整数常量：所有整数
    * 小数常量：所有小数
    * 字符常量：用单引号括起来的内容，里面只能放单个数字/字母/符号（java单引号与双引号有区别）
    * 布尔常量：较为特殊，只有两个值，true和 false
    * 空常量：null

#### 进制
> 进位制

* 二进制：逢二进一 0/1两个值
* 八进制：要求以0开头
* 十进制
* 十六进制：要求 0x 开头 或者 0X 如 0x1df3，RGB颜色选择器 fff0ff 每个原色使用两个十六进制表现的

###### 负数的二进制是十进制转为二进制取反加1，取反就是1变为0,0变为1

#### 计算机中的信息存储单位

* 位(bit)：标识一个二进制数 0 或者 1，是计算机存储信息的最基本单位
* 字节(byte)：一个字节由8个位组成

#### 注释

1. 单行注释 //
2. 多行注释 /* */
3. 文档注释 /** */

#### 变量
> 将不确定的数据进行存储,也就是说在内存中开辟一块空间来存储数据,内存就是一个运算区域,内存小cpu再快也没有用

* java是强类型语言,对类型的划分是很细致的,在内存中也分配了不同大小的空间
* 语法结构: 数据类型  变量名 = 初始化值
* 变量的分类: 基本数据类型 : 原始数据类型(4类8种), 引用数据类型
* 基本数据类型分类
    1. 整数型
        * byte：占一个字节 8位 -128到127 256个数
            -2的7次方 ~ 2的7次方-1
        * short：占两个字节 16位 
            -2的15次方 ~2的15次方-1
        * int：占四个字节 32位 默认java中整数是int类型
            -2的31次方 ~2的31次方-1
        * long：占八个字节 64位，定义long类型时后面带个L或者l进行标识
            -2的63次方 ~2的63次方-1
    2.浮点型
        * float：占四个字节, 单精度，定义float类型时后面带个F或者f进行标识
        * double：占八个字节 双精度，默认java中小数是double类型
    3.字符型
        * char：占两个字节 0~65535
			必须记住
				a~z -->97
				A~Z -->65
				0~9 -->48
    4.布尔型
        * boolean: true / false boolean理论上占八分之一个字节
* 变量的命名规则
    * 如果是一个单词 那么就都是小写
    * 如果是两个单词 第二单词首字母大写
* 使用变量的注意事项
    * 同一个区域内 {不能使用相同的变量名}
    * 局部变量在使用之前必须赋值，不使用可以不赋值
    * 一条语句可以定义多个变量 但是数据类型必须统一
* 数据类型转换
    * 自动类型转换(也叫隐式类型转换)
        * 小转大
        * 所有的byte类型,short类型,char类型**在计算时**，每个变量将被提升到int
        * byte,short,char -- int -- long -- float -- double
        * boolean不参与转换
        * char参与运算会先转换为对应int类型的值再参与运算，例如：char x = 'a'; int x1 = x + 1;  x1为98；char x = 'a'和 char x = 97 输出x的结果都为a
    * 强制类型转换(也叫显示类型转换)
        * 大转小
        * 可能会有精度的损失，一般不建议这样使用
        * 格式：目标数据类型 变量名 = (目标数据类型) (被转换的数据)

                int a = 3;
                byte b = 4;
                b = (byte)(a + b) 对
                b = (byte)a + b 错：b先被转为int

                byte b1 = 3;
                byte b2 = 4;
                byte b3 = b1 + b2; 错：先被转为int
                b1和b2是两个变量 变量里面存储的值都是变化的，所以在程序运行中 jvm是无法判断里面具体的值
                byte b4 = 4 + 5;
                4 和 5 都是常量 java有常量优化机制 就是在编译的时候直接把 4+5的结果赋值给了b4
                4 + 5 是一个常量计算，然后把结果赋值给byte类型的b4，如果结果在byte的范围之类就不会报错

                short s = 1;
                s = s+1;  // 报错

                short s = 1;
                s+=1;  // 正确，同++，--，-=

                (1) s = s+1报错，这句先执行s+1然后把结果赋给s，由于1为int类型，所以s+1的返回值是int，编译器自动进行了隐式类型转换。所以将一个int类型赋给short就会出错
                (2) 当jvm识别+=且原值为整型时，会先忽略原值的具体数据类型，先用int计算后，如果计算结果是int就直接转为原来的数据类型，如果不是int就强转为int然后再转回原数据类型
                从底层原理：
                而i+1 是将heap中数据直接送到寄存器中进行运算，运算结果会直接存放在heap中。
                i+=1 运行的底层Heap申请一个区域存放i，在数据区域开辟一个区域存放1，2个内存段的数据被送入到寄存器中进行运算，运算结果被放到heap中，数据区域运算后被自动释放后由GC回收
#### 作用域

1. 局部变量
> 在程序调用该方法的时候(进入语句块),局部变量才被创建并可用，随着方法(语句块)的结束,局部变量将被销毁
2. 全局变量
> 作用域是整个类

#### 键盘录入

* 第一步
    导包 import java.util.Scanner;
    位置 在class上面
* 第二步
    创建键盘录入对象
    Scanner sc = new Scanner(System.in);
* 第三步
    通过对象获取数据
    int x = sc.nextInt();

#### 运算符

1. 算术运算符 + - * / % ++ --
2. 赋值运算符 = += -= *= /= %=
3. 关系运算符 > < >= <= == !=
4. 逻辑运算符 ! & | ^ && ||
5. 位运算符 & | ^ ~ >> << >>>
6. 字符串连接运算符 +


* ##### 算术运算符
> \+ - * / % ++ --

1. "+" 号在java中有三种作用
    * 代表正号
    * 代表加法运算 
    * 字符串连接符
2. 整数相除只能得到整数,如果想得到小数,必须把数据转化成浮点型
3. /获取的是除法操作的商,%获取的是除法操作的余数

* ##### 赋值运算符
> = += -= *= /= %=

* ##### 关系运算符
> \> < >= <= == !=

###### 关系表达式的值只有真(true)和假(false)，结果是boolean类型

* ##### 逻辑运算符
> ! & | ^ && ||

1. &(与 and)
2. |(或 or)
3. !(非 not)
4. ^(异或)，两边相同为false，两边不相同为true
5. && (短路与)，当前面表达式为false时，结果为false，不进行后面表达式运算
6. || (短路或)，当前面表达式为true时，结果为true，不进行后面表达式的运算

###### 在实际应用开发中 更加倾向于使用 && ||

* ##### 位运算符
> & | ^ ~ >> << >>>

1. << 左位移运算符
    * 乘以2的左移位数n次方，3<<4 == 3 * 2 * 2 * 2 * 2
2. \>> 右位移运算符,带符号右移
    * 除以2的右移位数n次方，6>>2 == 6 / (2 * 2) == 1
    * 最高位是0 左边补齐0
    * 最高位是1 左边补齐1
3. \>>> 无符号右移运算符
    * 最高位不管是0 还是 1 左边补齐0
4. & 按位与
    * 0：false
    * 1：true
5. | 按位或
    * 0：false
    * 1：true
6. ~ 按位取反
7. ^ 按位异或
    * 相同为false
    * 不同为true
    * 一个数异或同一个数两次结果还是那个数

            1. 最有效率的算出2 * 8   --->   2<<3
            2. 快速实现两个变量值的交换
                int x = 1;
                int y = 2;  --->  x = 2  y = 1
                x = x ^ y;
                y = x ^ y;
                x = x ^ y;
#### 三元运算符 (三目运算符)
> 关系表达式 ? 表达式1 : 表达式2;

#### 流程控制语句

1. 顺序结构：从上向下，一行一行执行
2. 选择结构(分支结构)
    * if语句
        * if(){}
        * if(){}else{}
        * if(){}else if(){}else{}
    * switch

            switch(表达式){
                case 值1:
                    语句体1;
                    break;
                case 值2:
                    语句体2;
                    break;
                ...
                default: //可以省略,但是不建议省略
                    语句体n+1;
                break;
            }
            switch语句的结束条件
            1. 是遇到了break
            2. 是执行到了switch的右大括号
            default可以写在任意位置，不一定只能是在最后，只有case都不匹配后才会回头执行defalut，然后再向下执行，遇到break或者右大括号就结束，后面将不再判断case的值
3. 循环结构
* while 
* do..while 
* for

#### 特殊的流程控制语句
> break，continue，return

* break：只能在 switch 和 循环中，跳出循环
* continue：只能在循环中使用，结束本次循环，接着开始下一次循环
* return：结束方法

#### 方法

        格式
        修饰符 返回值类型 方法名(参数类型 参数名){
            方法体语句;
            return 返回值;
        }
        public: 修饰符 公共 公有的
        static 修饰符 静态的 
        void 返回值类型 void-->不确定的返回值
        main 方法名 符合命名规则即可 方便我们进行方法的调用
        (String[] args) 字符串类型数组 args 参数名
        {
            方法体语句 就是 完成功能的代码

        }
        return 结束方法用的
        返回值: 就是功能的结果 由return带给调用者

#### 方法的重载 overload
> 在同一个类中，方法名相同，参数列表不同，与返回值类型无关

###### 参数列表不同

* 参数个数不同
* 参数类型不同

###### 最佳匹配原则
> 在java中有一个大的原则：最佳匹配原则，当传实参的时候，如果有多个重载的方法都能接收该类型的数据(因为数据类型之间 有个自动转换)，那么会找一个"最匹配的"方法执行

#### 递归
> 函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己

###### 三要素

* 明确你这个函数想要干什么
* 寻找递归结束条件
* 我们要不断缩小参数的范围

#### 数组
> 数组是存储同一种数据类型多个元素的集合，也可以看成是一个容器，数组既可以存储基本数据类型，也可以存储引用数据类型，数组它是一个引用数据类型

* 格式：数据类型[] 数组名 = new 数据类型[数组长度]，[]代表数组，几个[]代表几维数组
* 动态初始化：指定了长度，由系统给出初始化值
    * 格式：数据类型[] 数组名 = new 数据类型[数组长度]
* 静态初始化：给出初始化值，由系统决定长度
    * 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3....}
    * 简化：数据类型[] 数组名 = {元素1,元素2,元素3.....};

#### 算法

* 选择排序
> 拿每个位置的值不断和其他位置的值进行比较，比该值大的就交换位置，比该值小的就不变（从小到大排序）

        for(int i = 0; i < arr.length; i++) {
            for(int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
* 冒泡排序
> 元素之间两两进行比较(相邻的两个元素进行比较) 大的右移

        for(int i = 0; i < arr.length; i++) {
            for(int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
* 二分查表法(折半查找)
> 根据元素查找该元素在当前数组中第一次出现的位置,也就是查索引,前提必须是有序的数组

        public static int findNumber(int[] arr, int value){
            int start = 0; // 0角标
            int end = arr.length - 1; // 最大角标
            int middle = (start + end) / 2; // 中间角标

            while(arr[middle] != value){
                if(value > arr[middle]){
                    start = middle + 1;
                }else if(value < arr[middle]){
                    end = middle - 1;
                }
                if(start > end){
                    return -1;
                }
                middle = (start + end) / 2;
            }
            return middle;
        }

#### 内存结构
> java程序在运行时需要在内存中分配空间，为了提高运算效率又对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式

* 栈内存：存储局部变量
* 堆内存：存储new出来的数组或对象(new 出来的叫实体)，每一个实体都有内存地址值，实体中的变量都有默认初始化值，实体在不使用的情况下会在不确定的时间被垃圾回收器自动回收
    * byte short int 初始值 0
    * long 初始值 0L
    * float 初始值 0.0F
    * double 初始值 0.0D
    * boolean 初始值 false
    * char 初始值 '\u0000' 表示空
    * 引用数据类型 初始值 null
    

* 方法区
* 本地方法区：和系统相关
* 寄存器：给CPU使用
* 常量池：常量

#### 可变参数
> 在设计方法时，方法的最后一个形参的个数是变动的。适用于参数个数不确定，类型确定的情况，可以将可变参数当做一个数组来看

* 注意事项
    * 可变参数必须位于最后一项
    * ...位于变量类型和变量名之间，前后有无空格都可以
* 语法格式

        权限修饰符 返回值类型 方法名(类型1 参数1, 类型n...参数n){
            //方法体
        }


day7 java工具类 完























*一辈子很短，努力的做好两件事就好；第一件事是热爱生活，好好的去爱身边的人；第二件事是努力学习，在工作中取得不一样的成绩，实现自己的价值。*