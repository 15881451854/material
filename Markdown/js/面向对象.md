## 面向对象
> 面向对象是利用对象进行编程的一种思想（Object-oriented programming,缩写: OOP）

> 面向对象主要有四大特性: 抽象，封装，继承，多态

> 假设我是女娲，我准备捏一些人，首先，人应该有哪些基本特征：1.有四肢 2.有大脑 3.有器官 4.有思想 我们就有了第一个模型，这就是抽象。其次，我和西方上帝是好友，我想我的这个想法能够提供给他用，但是我不想让他知道里面细节是怎么捏出来的，用的什么材料，他也不用考虑那么多，只要告诉我他要捏什么样的人就可以了。这就是封装。然后，我之后创造的人都以刚才的模型做为模板，我创造的人都有我模型的特征，这就是继承。最后，我觉得为了让人更丰富多彩，有男女之分。这就是多态。

#### javascript两种开发模式

1. 面向过程
2. 面向对象

#### 对象的组成

1. 属性(变量): 对象有什么
2. 方法(函数): 对象能做什么

#### 创建对象

单个对象

1. 字面量（推荐）
> var student = {id:10,name:'小明',age:18}

2. 构造函数
> var student = new Object()
> student.id = 10;
> student.name = '王铁锤';
> student.age = 18;

> 以上两种方式的缺点：使用同一个接口创建很多对象，会产生大量的重复代码

多个对象

3. 封装工厂函数
> 为了减少重复代码，对上述代码进行封装
> 缺点：无法识别对象是由谁生成的

4. 自定义构造函数

示例
    
    function Student(name, age){
        this.name = name;
        this.age = age;
        this.sayName = function(){
            alert(this.name);
        }
    }
    var s1 = new Student("王铁锤", 18);

new调用构造函数时经历以下4步
1. 创建一个Object对象
2. 将构造函数的this指向这个对象
3. 执行构造函数中的代码
4. 返回Object对象

组成部分

* 实例（可见）
    * 用new关键字生成的对象称为实例
    * 实例包含一个内部属性**prototype**，指向原型对象

* 原型对象（不可见）
    * 与构造函数伴随而来
    * constructor：指向构造函数，新创建的构造函数默认属性
    * 原型对象中的属性和方法可以让所有对象实例共享
    * 获取:（通过构造函数：构造函数.prototype）

* 构造函数（可见）

判断原型和实例的关系（返回布尔值）
1. constructor: 一般用于判断该实例是否由某一构造函数生成
> 实例.constructor == Student //true

2. instanceof: 检测某个对象是不是某一构造函数的实例
> 实例 instanceof Student //true
> 实例 instanceof Object //true

3. isPrototypeOf: 判断当前对象是否为实例的原型
> 原型对象.isPrototypeOf(实例) //true

#### 构造函数与普通函数的区别
> 唯一区别：调用方式不同

* 任何函数，只要通过new操作符来调用，它就可以作为构造函数；
* 而任何构造函数，如果不通过new 操作符来调用，那它跟普通函数无区别。

> 约定：构造函数名首字母大写

#### this

* 用new关键字调用：this指向生成的实例对象
* 普通函数调用：this指向调用函数的对象

#### 实际应用
> 构造函数方法很好用，但是单独使用存在一个浪费内存的问题（所有的属性/方法都写入实例中）。这样既不环保，也缺乏效率。

解决方案:构造函数+原型对象

* 构造函数中添加属性
* 原型对象中添加方法

例

    var Firework = function(){};
    Firework.prototype.move = function(){};
    Firework.prototype.show = function(){};
    // 如果有多个方法，可以重置原型对象
    Firework.prototype = {
        constructor: Firework,
        move(){},
        show(){}
    }

> 实例中的属性减少了，原型对象中的方法又能被所有的实例共享，最大限度的节省了内存

#### 总结：面向对象其实只做两件事情
1. 创建并描述对象
    * 添加属性  (这个对象有什么)
    * 添加方法  (这个对象能干什么)
    > 添加方法遵循单一原则：一个方法只做一件事情
2. 操作对象

#### ES5对象扩展

* 值属性（有值的属性）
    * configurable:可配置型（总开关，控制其他属性特性）
    * writable：可写性
    * enumerable:可枚举性（枚举：遍历。在原型里面颜色比较暗的就是不可枚举的)
    * value：值
* 存储属性（了解）

1. Object.create(prototype, descriptors)
> 以指定的原型创建对象

    var example = Object.create(Array.prototype, {
        size: {
            value: "large",
            enumerable: true
        },
        shape: {
            value: "round",
            enumerable: true
        }
    });
    console.log(example);

2. Object.defineProperty(object, propertyname, descriptor)
> 对指定的对象的一个属性设置属性特性

    var lemon = {
        name:'lemon',
        age:30
    }
    Object.defineProperty(lemon,'hobby',{
        value:'修车'
    })
**传统方式添加属性：属性特性全部默认为true
Object.defineProperty：属性特性默认为false**

3. Object.defineProperties(object, descriptors)
> 对指定的对象的一组属性设置属性特性

4. Object.getOwnPropertyDescriptor(object, propertyname)
> 返回属性特性

5. Object.keys(object)
> 返回对象所有可枚举属性的名称

6. Object.getOwnPropertyNames(object)
> 返回所有属性的名称（哪怕说是不能枚举的属性）


## 继承
> 子类继承父类的属性和方法，让子类也拥有这些属性和方法, 并可以扩展

###### 原型链
> 实例与Object原型对象之间的链条称为原型链

###### 原型模式的访问机制（原型搜索机制）

* 读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值；
* 如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值
* 如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）；
* 如果再Object的原型对象中还搜索不到，则抛出错误；

###### 重置原型对象
> 重置原型对象，可以一次性给原型对象添加多个方法，但切断了与原来原型对象的联系

    function Popover(){}
        Popover.prototype = {
            show:function(){},
            hide:function(){}
        }

#### 原型链继承
> 拿父类实例来充当子类原型对象

    // 父类
    function Person(name,age,gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    Person.prototype.say = function(){
        console.log('hello, my name is ' + this.name);
    }
    Person.prototype.eat = function(){
        console.log('hello, my name is ' + this.name + ',我是一个吃货');
    }
    // 子类
    function Man(name,age){
        this.name = name;
        this.age = age;
        this.gender = '男';
    }
    Man.prototype = new Person();  // 拿父类实例来充当子类原型对象
    var m1 = new Man('laoxie',18);
    m1.say();  // say()方法在Man原型对象的原型对象里

缺点：
* 无法继承构造函数中的属性
* 创建子类实例时，无法向父类构造函数传参
* 原型对象中存在多余的属性

#### 借用构造函数 (解决了无法继承构造函数中的属性)
> 借父类的构造函数来增强子类实例，相当于把父类的实例属性复制一份给子类实例

    // 父类
    function Person(name,age,gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    Person.prototype.say = function(){
        console.log('hello, my name is ' + this.name);
    }
    Person.prototype.eat = function(){
        console.log('hello, my name is ' + this.name + ',我是一个吃货');
    }
    // 子类
    function Man(name,age){
        Person.call(this,name,age,'男');
    }
函数方法
* call: 父类构造函数.call(子类实例,参数1,参数2,参数3...)，会执行调用的函数
* apply: 父类构造函数.apply(子类实例,[参数1,参数2,参数3...])，会执行调用的函数
* bind: 也会改变this指向，但不会执行
> call与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组

    //aplly用法：借用方法
    var arr = [20,2,40,33,21,8,22,46,32]
    Math.max.apply(null,arr)

缺点：
* 无法实现函数复用
* 函数太多就会影响性能，占用更多内存

#### 组合继承

    // 父类
    function Person(name,age,gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    Person.prototype.say = function(){
        console.log('hello, my name is ' + this.name);
    }
    Person.prototype.eat = function(){
        console.log('hello, my name is ' + this.name + ',我是一个吃货');
    }
    // 子类
    function Man(name,age){
        Person.call(this,name,age,'男');
    }
    Man.prototype = new Person();
    Object.defineProperty(Man.prototype,'constructor',{
        configurable:true,
        value:Man,
    })
    var m1 = new Man('laoxie',18);
    m1.say();  // say()方法在Man原型对象的原型对象里

* 继承属性：借用构造函数
* 继承属性：借用构造函数

缺点（原型链继承法的缺点）
* 在原型对象中生成多余的属性
* 多次执行父类构造函数

#### 原型式继承(解决原型链继承法的缺点：生成多余的属性)

* 先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例

        function inherit(o){
            // 创建临时构造函数
            function F(){}
            // 把传入的对象作为临时构造函数的原型对象
            F.prototype = o;
            // 返回临时构造函数的实例
            return new F();
        }
        Man.prototype = inherit(Person.prototype);
        Object.defineProperty(Man.prototype,'constructor',{
            configurable:true,
            value:Man,
        })
* ES5版本的原型式继承：Object.create()

#### 寄生组合继承法(完美的继承方法)

* 继承属性：借用构造函数
* 继承方法：原型式继承

==**思考：为什么不能直接把父类的prototype赋值给子类的prototype：`Man.prototype = Person.prototype;`对象的赋值只是引用的赋值` 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类**==

## ES6中的继承

#### Class定义类
> ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类

    //定义类
    class Person {
        constructor(name,age) {
            this.name = name;
            this.age = age;
        }
        getInfo() {
            return `我叫${this.name},今年${this.age}岁`;;
        }
    }
* 写在类里面的方法实际是给Person.prototype添加方法
* constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。如果没有constructor方法，则得使用默认的constractor方法

#### extends继承

    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
    }

    class Man extends Person {
        constructor(name, age, gender) {
            // 类似解构构造函数法
            // 改变this指向，执行父类构造函数
            super(name,age);
            this.gender = gender;
        }
    }  
* 子类继承了父类，如果之类没有constructor，默认指向父类的constructor，不用super，在子类构造函数中有constructor则必须调用super方法，可以将父类的参数传递过来。
* 子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。

#### 静态方法
> 如果在一个方法前，加上static关键字，这就称为“静态方法”

    class Person {
        constructor(){
            this.name = 'laoxie',
            this.age = 18;
        }
        static getInfo(){
            return this.name
        }
        say(){
            console.log(`Hello everyone, my name is ${this.name}, I'm ${this.age} years old`)
        }
    }
    class Man extends Person {}
* 静态方法方法不会被实例继承，而是直接通过类来调用Person.getInfo()
* 父类的静态方法，可以被子类继承Man.getInfo()

###### 拓展内置原型对象

    if(!Array.prototype.odd){
        Array.prototype.odd = function(){}
    }
    !Array.prototype.odd && (Array.prototype.odd = function(){})

###### 插件编写
> 使用匿名函数。小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号对返回的，就是一个匿名函数的Function对象

        ;(function(){
            ----
        })();


*一辈子很短，努力的做好两件事就好；第一件事是热爱生活，好好的去爱身边的人；第二件事是努力学习，在工作中取得不一样的成绩，实现自己的价值。*